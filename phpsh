#!/usr/local/bin/php72 -q
# PHP REPL / Shell - v 0.5 - Copyright (c) 2003-<?= date('Y') ?> Weston Cann
# Released under GPL version 2, see bottom of source file for details
# <?= __FILE__ ?> 
# Enter .h for help
<?php 
ini_set('display_errors',1);
set_include_path(get_include_path() . PATH_SEPARATOR. dirname(__FILE__));
set_error_handler('phpsh_throw_error_exception',E_ALL);
register_shutdown_function('phpsh_on_shutdown');
define('DEFAULT_CRASH','phpsh_crash.hist');
define('DEFAULT_HIST','phpsh.hist');
$history = [];

print "\n";

if(isset($argv)) { // process arguments as php to execute
	foreach($argv as $arg) 
		if($arg != "-r") 
			include_once($arg);
		else
			include_once(DEFAULT_CRASH); 
}

if(is_callable("readline")) { // figure out our readline strategy
	function phpsh_readln() { 
		return rtrim(readline()); 
	}
} else {
	function phpsh_readln() {
		$fp=fopen("/dev/stdin", "r");
    	$input=fgets($fp, 4096);
    	fclose($fp);
    	return rtrim($input);
	}
}

do { // main read-eval-print loop
	print "phpsh> ";
	$cmdline = phpsh_readln();

	if(!$cmdline) 
		continue;

	$firstchar = substr($cmdline,0,1);
	if($firstchar == '.') {  // phpsh-specific commands
		$sub = trim(substr($cmdline,1));
		if(!$sub) {
			echo "missing phpsh command?\n";
			continue;
		}
		$cmd_parts = preg_split("/\s+/",substr($cmdline,1),null,PREG_SPLIT_NO_EMPTY);
		$cmd = is_array($cmd_parts) ? $cmd_parts[0] : null;
		switch($cmd) {
			case 'q': 
				exit;
			case 's': 
				phpsh_cmd_save($cmd_parts[1] ?? null);
				break;
			case 'l':
				$histfile = $cmd_parts[1] ?? DEFAULT_HIST;
				if(file_exists($histfile)) 
					include($histfile);
				else 
					echo "can't find $histfile\n";
				break;
			case 'r':
				if(file_exists(DEFAULT_CRASH))
					include(DEFAULT_CRASH);
				else 
					echo "can't find ",DEFAULT_CRASH,"\n";
				break;
			case 'r':
			default:
				echo "$cmdline -- command not found.\n";
			case 'h': 
				phpsh_cmd_help();
		}
		continue;
	}

	$lastchar = substr($cmdline,-1);
	if(($lastchar == ';') || ($lastchar == '}')) {// No Return Value
		$evalExp = $cmdline;
		$type = 'instructions';
	} else {
		$evalExp = "return($cmdline);";
		$type = 'expression';
	}

	try {
		$returnval = eval($evalExp);
		if($type == 'expression')
			echo phpsh_showVar($returnval),"\n"; 
		$history[] = $cmdline;	
	} catch(ParseError $e) {
		echo "CAUGHT parse error",$e,"\n";
	} catch(\Throwable $t) {
		echo "CAUGHT ",$t,"\n";
	}
	
} while(TRUE);


function phpsh_throw_error_exception($number = 0, $str = '',$file = null,$line = null) {
	throw new ErrorException($str, 0, $number, $file, $line);
	die("control flow shouldn't ever reach here");
}

function phpsh_showVar($v) {
	// To Do: deeper inspection?
	$rv = '(phpsh doesn\'t know how to string-ify this variable or result)';

	if(is_array($v)) {
		$rv = array('[');
		foreach($v as $key => $val) 
			array_push($rv,"\n  ",$key,' => ',phpsh_showVar($val));
		if(count($v) > 0) $rv[] = "\n";
		$rv[] = ']';
		$rv = implode(null,$rv);
	}
	else if($v === null) 
		$rv = "null";
	else if(is_object($v) && method_exists($v,'__toString')) 
		$rv = $v->__toString();
	else 
		$rv = var_export($v,true);

	return $rv;
}



function phpsh_cmd_save($filename,$avoid_last=false) {
	global $history;
	if(!$filename) {
		$filename = DEFAULT_HIST;
		echo "save command .s needs target file, using ",DEFAULT_HIST," in current working directory ",getcwd(),"\n";
	} 
	if($avoid_last) 
		array_pop($history);
	$output = "<?php \n\n".implode(";\n",$history).";";
	if(!file_put_contents($filename,$output))
		echo "error writing file $filename\n";
	else
		echo "saved history to $filename\n";
}

function phpsh_cmd_help() {
	$default_crash = DEFAULT_CRASH;
	echo <<<EOD
Available phpsh commands:
  .h       - prints this command list
  .s <arg> - saves command history to filename <arg>
  .l <arg> - shortcut for include(<arg>)
  .r       - shortcut for include("$default_crash")
  .q       - quit

Beyond that, everything else is simply filtered through PHP's `eval` function. phpsh will attempt to automatically yield a string representation of entries that don't end with a semi-colon or a block delimiter. 

EOD;
}

function phpsh_on_shutdown() {
	$err = error_get_last();	
	if($err && ($err['type'] === E_ERROR)) {
		phpsh_cmd_save(DEFAULT_CRASH);
		echo "history saved to ",DEFAULT_CRASH,", use .r on next run to replay";
	}
	echo "\n";
}
?>
